10/27
 
スキルチェック  
Bランク　1問  
 
-------------------------------------------
・全日数、有給日数が与えられる  
・毎日の日程が与えられる  
・日程が下記表の通りの表記になる  
・有給を使って、取れる最大連休日数を算出して出力  

| text | mean |
|:-----------:|:------------:|
| work | 出勤日 |
| off | 休日 |
 
-------------------------------------------
 
```ruby
days, pto = gets.split.map(&:to_i)                       # 全日数、有給日数を取得
sched = days.times.map{gets.chomp}                       # 毎日の日程を取得

wd = []                                                  # 出勤日をindex番号で記録
sched.each_with_index do |d,i|
  wd << i if d == "work"
end

lengs = 0                                                # 連続休日日数を記録

wd = wd.combination(pto).to_a                            # 出勤日の各パターンを算出
wd.each do |arr|
  try = sched.dup                                        # 計算用の全日程を作成
  arr.each {|i| try[i] = "off" }                         # 出勤日の各パターンの有給を取ってみる
  try.chunk{|n| n == "off"}.each do |bool,arr|
    lengs = [lengs, arr.size].max if bool                # 最大連休数を更新
  end
end

puts lengs                                               # 最大連休日数を出力
```
↑考え方は合ってるが、日数が多くなると、膨大な計算になるため、効率が悪い

↓効率よくする(各日を開始日として試し、最大連休日数を組み合わせた結果だけを判定)

```ruby
days, pto = gets.split.map(&:to_i)
sched = days.times.map{gets.chomp}

lengs = 0

(0...days).each do |start|                               # 開始日を1日ずつ後にする
  used = 0
  (start...days).each do |i|
    used += 1 if sched[i] == "work"                      # 出勤日を有給に変更し、使った有給をカウント
    break if used > pto                                  # 有給日数超えたら処理終了
    lengs = [lengs, i - start + 1].max                   # 最大連休日数を更新
  end
end

puts lengs                                               # 最大連休日数を出力
```

